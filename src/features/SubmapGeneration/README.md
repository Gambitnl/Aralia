# Submap Generation

This feature is responsible for the procedural generation of local submaps that the player explores.

## Architecture & Design History

This document provides a deep dive into the submap generation system for the Aralia RPG. It explains how the system works in relation to the core design requirements and explores potential "better tools"—both algorithmic and technological—for future enhancements.

### How the Current Submap System Works

The system in place is a robust and well-designed **deterministic procedural generation** system. This means it creates dynamic, random-looking maps that are actually the same every time for a given starting "seed." This is a perfect design choice for ensuring a consistent and replayable world in each playthrough.

The core of this system is the `useSubmapProceduralData` hook (`src/hooks/useSubmapProceduralData.ts`), which acts as the central engine for generating the *data* of a submap. It takes the parent world map coordinates and biome ID as input and produces a memoized object containing the placement of all major features, including paths and seeded features like ponds or ruins.

The visual appearance of each biome is defined in `src/config/submapVisualsConfig.ts`, which acts as a "visual recipe book," separating artistic and design decisions from the core generation logic.

#### Path Connectivity

The illusion of connected roads between adjacent world map tiles is achieved in a clever, emergent way. Each submap generates its own path segment independently, but because the generation algorithm is deterministic and seeded by the world map coordinates, the paths naturally align at the borders. The system does not track a single, continuous "road object" across the entire world map.

#### Travel Time

Travel time is currently calculated using fixed, abstract time costs in the `handleMovement` action handler (`src/hooks/actions/handleMovement.ts`). A move between world map tiles costs 1 hour, and a move within a submap costs 30 minutes. The architecture is designed to be extensible to incorporate more granular calculations based on factors like mount speed, terrain type (roads), and character-specific movement rates.

### Potential Future Improvements

The following are summaries of architectural deep dives and plans for potential future enhancements to the submap generation system.

#### 1. Gradual Biome Transitions

**Status**: Not Implemented

**Concept**: To improve immersion, the system could be enhanced to create smooth, gradual transitions between different biomes. When a player travels from a "plains" world tile to a "forest" world tile, the edge of the new forest submap would contain a few rows of plains terrain.

**Implementation Plan**: This would be an algorithmic enhancement, not a change of tools. The `handleMovement` action would be modified to pass the `previousBiomeId` and `entryDirection` to the `useSubmapProceduralData` hook. The rendering logic in `SubmapPane.tsx` would then use this context to "paint" a few rows of the previous biome's visuals onto the edge of the new submap.

#### 2. Cellular Automata for Organic Maps

**Status**: Planned

**Concept**: For biomes like `cave` or `dungeon` that should feel more organic and less like open fields, the **Cellular Automata (CA)** algorithm is a "better tool." It excels at creating natural, cavernous layouts by applying simple rules to a grid of cells based on their neighbors.

**Implementation Plan**:
1.  Create a self-contained `cellularAutomataService.ts`.
2.  Modify the `useSubmapProceduralData.ts` hook to act as a router, calling the CA service when the biome is `cave` or `dungeon`.
3.  Update the rendering logic in `SubmapPane.tsx` to display the grid data generated by the CA service.

#### 3. Wave Function Collapse for Structured Maps

**Status**: Planned

**Concept**: For highly structured environments like `villages` or `ruins`, the **Wave Function Collapse (WFC)** algorithm is a powerful tool. It generates logical, non-random layouts based on a predefined set of adjacency rules (e.g., "a road tile must connect to another road tile").

**Implementation Plan**:
1.  Integrate a third-party WFC library.
2.  Define tile and adjacency rulesets for specific biomes (e.g., in `src/config/wfcRulesets/village.ts`).
3.  Create a `wfcService.ts` to wrap the library.
4.  Update `useSubmapProceduralData.ts` to call the WFC service for relevant biomes.

#### 4. PixiJS for High-Performance Rendering

**Status**: Planned (Major Refactor)

**Concept**: To drastically improve rendering performance and unlock advanced visual effects (lighting, particles), the current system of rendering hundreds of React `<div>` elements could be replaced with a WebGL-based canvas managed by the **PixiJS library**.

**Implementation Plan**:
1.  Integrate the PixiJS library.
2.  Create a dedicated React component (`SubmapRendererPixi.tsx`) to encapsulate all PixiJS logic.
3.  Refactor `SubmapPane.tsx` to act as a container that manages data and renders the new PixiJS component instead of the DOM-based grid. This is a significant architectural change that would require re-implementing interactivity like tooltips.
