
/**
 * @file ActionPane.tsx
 * This component displays available actions to the player.
 * It includes standard actions (Talk, Take, Move), Oracle interaction,
 * and dynamic actions generated by Gemini (e.g. from Look Around).
 *
 * TODO: Add unit tests for ActionPane - covers Oracle input flow, System menu toggle,
 * Gemini-generated actions, and context-aware action rendering.
 * Tracked in: docs/tasks/testing-overhaul/01-CORE-UI.md
 */
import React, { useState, useRef, useEffect, useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Menu, X } from 'lucide-react';
import { Location, Action, NPC, Item } from '../types';
import { getSubmapTileInfo } from '../utils/submapUtils';
import { SUBMAP_DIMENSIONS } from '../config/mapConfig';
import { BTN_BASE, BTN_SIZE_LG } from '../styles/buttonStyles';
import { canUseDevTools } from '../utils/permissions';
import { logger } from '../utils/logger';

interface ActionPaneProps {
  currentLocation: Location;
  npcsInLocation: NPC[];
  itemsInLocation: Item[];
  onAction: (action: Action) => void;
  disabled: boolean;
  geminiGeneratedActions: Action[] | null;
  isDevDummyActive: boolean;
  unreadDiscoveryCount: number;

  hasNewRateLimitError: boolean;
  subMapCoordinates?: { x: number; y: number };
  worldSeed?: number;
}

interface ActionButtonProps extends Omit<React.ButtonHTMLAttributes<HTMLButtonElement>, 'onClick'> {
  action: Action;
  onClick: (action: Action) => void;
  disabled: boolean;
  className?: string;
  isGeminiAction?: boolean;
  badgeCount?: number;
  hasNotification?: boolean;
}

const ActionButton = React.forwardRef<HTMLButtonElement, ActionButtonProps>(({
  action,
  onClick,
  disabled,
  className = '',
  isGeminiAction = false,
  badgeCount,
  hasNotification,
  ...props // Forward other props like role, tabIndex, onKeyDown
}, ref) => {
  const baseClasses = `${BTN_BASE} ${BTN_SIZE_LG}`;

  let colorClasses = "btn-primary";

  // Determine color based on action type
  if (action.type === 'toggle_party_overlay') colorClasses = "btn-green";
  else if (action.type === 'save_game') colorClasses = "btn-yellow";
  else if (action.type === 'go_to_main_menu') colorClasses = "btn-red";
  else if (action.type === 'toggle_dev_menu') colorClasses = "btn-orange";
  else if (action.type === 'gemini_custom_action') colorClasses = "btn-teal";
  else if (action.type === 'ask_oracle' || (action.type === 'custom' && action.label.toLowerCase().includes('oracle'))) colorClasses = "btn-purple";
  else if (action.type === 'ANALYZE_SITUATION') colorClasses = "btn-indigo";
  else if (action.type === 'TOGGLE_DISCOVERY_LOG') colorClasses = "btn-lime";
  else if (action.type === 'TOGGLE_LOGBOOK') colorClasses = "btn-amber";
  else if (action.type === 'TOGGLE_GLOSSARY_VISIBILITY') colorClasses = "btn-indigo-dark";
  else if (action.type === 'TOGGLE_GAME_GUIDE') colorClasses = "btn-blue";

  if (isGeminiAction && action.type !== 'gemini_custom_action') {
    colorClasses = "btn-teal";
  }

  const handleClick = (e: React.MouseEvent) => {
    // Ensure targetId for movement actions is a string to avoid type errors, without mutating prop
    if (action.type === 'move' && action.targetId && typeof action.targetId !== 'string') {
      onClick({ ...action, targetId: String(action.targetId) });
    } else {
      onClick(action);
    }
  };


  return (
    <motion.button
      ref={ref}
      {...{
        layout: true,
        initial: { opacity: 0, scale: 0.8 },
        animate: { opacity: 1, scale: 1 },
        exit: { opacity: 0, scale: 0.8 },
        whileHover: { scale: 1.05 },
        whileTap: { scale: 0.95 },
      } as any}
      onClick={handleClick}
      disabled={disabled}
      className={`${baseClasses} ${colorClasses} ${className}`}
      aria-label={action.label}
      type="button"
      aria-disabled={disabled}
      {...props}
    >
      {action.label}
      {badgeCount !== undefined && badgeCount > 0 && (
        <span className="absolute -top-2 -right-2 inline-flex items-center justify-center px-2 py-1 text-xs font-bold leading-none text-red-100 bg-red-600 rounded-full">
          {badgeCount > 99 ? '99+' : badgeCount}
        </span>
      )}
      {hasNotification && (
        <span className="absolute -top-1 -right-1 h-3 w-3 rounded-full bg-red-500 border-2 border-gray-800 animate-pulse"></span>
      )}
    </motion.button>
  );
});

ActionButton.displayName = 'ActionButton';

const ActionPane: React.FC<ActionPaneProps> = ({
  currentLocation,
  npcsInLocation,
  itemsInLocation,
  onAction,
  disabled,
  geminiGeneratedActions,
  isDevDummyActive,
  unreadDiscoveryCount,

  hasNewRateLimitError,
  subMapCoordinates,
  worldSeed,
}) => {
  const [isOracleInputVisible, setIsOracleInputVisible] = useState(false);
  const [oracleQuery, setOracleQuery] = useState('');
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const menuRef = useRef<HTMLDivElement>(null);
  const menuTriggerRef = useRef<HTMLButtonElement>(null);
  const menuItemRefs = useRef<(HTMLButtonElement | null)[]>([]);

  /**
   * System and utility actions quickly overcrowd the primary grid on small screens.
   * We group them into a collapsible "System" menu to preserve horizontal space
   * for context-aware actions (NPC interactions, items, movement, etc.).
   */
  const systemMenuActions = useMemo(
    () => [
      { action: { type: 'TOGGLE_DISCOVERY_LOG', label: 'Discoveries' }, badgeCount: unreadDiscoveryCount },
      { action: { type: 'TOGGLE_QUEST_LOG', label: 'Quests' } },
      { action: { type: 'TOGGLE_LOGBOOK', label: 'Dossiers' } },
      { action: { type: 'TOGGLE_GLOSSARY_VISIBILITY', label: 'Glossary' } },
      { action: { type: 'toggle_party_overlay', label: 'Party' } },
      { action: { type: 'TOGGLE_GAME_GUIDE', label: 'Game Guide' } },
      { action: { type: 'save_game', label: 'Save Game' } },
      { action: { type: 'go_to_main_menu', label: 'Main Menu' } },
      canUseDevTools()
        ? { action: { type: 'toggle_dev_menu', label: 'Dev Menu' }, hasNotification: hasNewRateLimitError }
        : null,
    ].filter(Boolean) as { action: Action; badgeCount?: number; hasNotification?: boolean }[],
    [hasNewRateLimitError, isDevDummyActive, unreadDiscoveryCount],
  );

  // Focus management for menu
  useEffect(() => {
    if (isMenuOpen) {
      // Focus first item when opened
      const firstItem = menuItemRefs.current[0];
      if (firstItem) {
        // Small timeout to allow framer-motion to mount the element
        setTimeout(() => firstItem.focus(), 50);
      }
    } else {
      // Focus trigger button when closed, ONLY if it was previously open (to avoid focus steal on mount)
      // Actually, we should check if focus is currently inside the menu before returning it,
      // but simpler is: if we just closed it, return focus.
      if (document.activeElement && menuRef.current?.contains(document.activeElement)) {
         menuTriggerRef.current?.focus();
      }
    }
  }, [isMenuOpen]);

  // Reset refs array when items change
  useEffect(() => {
    menuItemRefs.current = menuItemRefs.current.slice(0, systemMenuActions.length);
  }, [systemMenuActions]);

  // Close menu when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node) && !menuTriggerRef.current?.contains(event.target as Node)) {
        setIsMenuOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  const handleMenuKeyDown = (e: React.KeyboardEvent, index: number) => {
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      const nextIndex = (index + 1) % systemMenuActions.length;
      menuItemRefs.current[nextIndex]?.focus();
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      const prevIndex = (index - 1 + systemMenuActions.length) % systemMenuActions.length;
      menuItemRefs.current[prevIndex]?.focus();
    } else if (e.key === 'Escape') {
      e.preventDefault();
      setIsMenuOpen(false);
      menuTriggerRef.current?.focus();
    } else if (e.key === 'Tab') {
      // Allow default Tab behavior to leave the menu, but close it
      setIsMenuOpen(false);
    }
  };


  const generalActions: Action[] = [];

  // Populate interactions for NPCs and Items in current location
  if (!currentLocation.id.startsWith('coord_')) {
    npcsInLocation.forEach((npc) => {
      generalActions.push({ type: 'talk', label: `Talk to ${npc.name}`, targetId: npc.id });
    });
  }

  if (!currentLocation.id.startsWith('coord_')) {
    itemsInLocation.forEach((item) => {
      generalActions.push({ type: 'take_item', label: `Take ${item.name}`, targetId: item.id });
    });
  }

  // Move actions for named exits (standard non-compass moves)
  if (currentLocation.exits) {
    Object.entries(currentLocation.exits).forEach(([direction, exit]) => {
      if (!['North', 'South', 'East', 'West', 'NorthEast', 'NorthWest', 'SouthEast', 'SouthWest'].includes(direction)) {
        // Handle exit being string (legacy) or object
        const targetId = typeof exit === 'string' ? exit : exit.targetId;
        // Optionally verify exit is visible if it's an object
        if (typeof exit === 'string' || !exit.isHidden) {
          generalActions.push({ type: 'move', label: `Go ${direction}`, targetId: targetId });
        }
      }
    });
  }

  // Check for Village/Town Entry
  // Method 1: Procedural village terrain on coordinate locations AND predefined locations
  // TODO[VILLAGE-ENTRY-REFACTOR]: Consider extracting adjacency check to a utility
  // (e.g., getAdjacentVillageEntry() in submapUtils.ts) for reuse in compass/movement handlers.
  if (subMapCoordinates && worldSeed !== undefined) {
    // Only check cardinal directions (N/E/S/W) for village entry - no diagonals
    // The offset represents where the VILLAGE is relative to the player
    // So if village is at offset {x: 1, y: 0}, player enters from the WEST
    const cardinalOffsets = [
      { x: 0, y: -1, entryDirection: 'south' },  // Village is north of player -> enter from south
      { x: 0, y: 1, entryDirection: 'north' },   // Village is south of player -> enter from north
      { x: -1, y: 0, entryDirection: 'east' },   // Village is west of player -> enter from east
      { x: 1, y: 0, entryDirection: 'west' },    // Village is east of player -> enter from west
    ];

    let adjacentToVillage = false;
    let entryDirection: string | null = null;

    for (const offset of cardinalOffsets) {
      const checkX = subMapCoordinates.x + offset.x;
      const checkY = subMapCoordinates.y + offset.y;

      // Only check within submap bounds
      if (checkX >= 0 && checkX < SUBMAP_DIMENSIONS.cols &&
        checkY >= 0 && checkY < SUBMAP_DIMENSIONS.rows) {
        const { effectiveTerrainType: checkType } = getSubmapTileInfo(
          worldSeed,
          currentLocation.mapCoordinates,
          currentLocation.biomeId,
          SUBMAP_DIMENSIONS,
          { x: checkX, y: checkY }
        );

        if (checkType === 'village_area') {
          adjacentToVillage = true;
          entryDirection = offset.entryDirection;
          break; // Use first found village direction
        }
      }
    }

    if (adjacentToVillage && entryDirection) {
      if (canUseDevTools()) logger.debug('Player is cardinally adjacent to village', { entryDirection });
      generalActions.push({
        type: 'ENTER_VILLAGE',
        label: 'Enter Village',
        payload: { entryDirection } // Pass entry direction for spawn positioning
      });
      generalActions.push({ type: 'OBSERVE_VILLAGE', label: 'Scout Village' });
    }
  }

  // Method 2: Predefined town/settlement locations
  const townKeywords = ['town', 'village', 'city', 'settlement', 'hamlet'];
  const isTownLocation = townKeywords.some(keyword =>
    currentLocation.name.toLowerCase().includes(keyword) ||
    currentLocation.id.toLowerCase().includes(keyword)
  );

  if (isTownLocation && !currentLocation.id.startsWith('coord_')) {
    generalActions.push({ type: 'ENTER_VILLAGE', label: 'Enter Town' });
    // Add contextually appropriate actions when at a town location
    generalActions.push({ type: 'OBSERVE_TOWN', label: 'Scout Town' });
    generalActions.push({ type: 'APPROACH_TOWN', label: 'Approach Cautiously' });
  }

  const handleAskOracleClick = () => setIsOracleInputVisible(true);
  const handleOracleSubmit = () => {
    if (oracleQuery.trim() && !disabled) {
      onAction({ type: 'ask_oracle', label: 'Ask the Oracle', payload: { query: oracleQuery.trim() } });
      setOracleQuery('');
      setIsOracleInputVisible(false);
    }
  };

  return (
    <div className="bg-gray-800 p-4 rounded-lg shadow-xl border border-gray-700">
      <h2 className="text-xl font-bold text-amber-400 mb-4 border-b-2 border-amber-500 pb-2">Actions</h2>

      {/* Top Row: Oracle, Analyze, System Toggles */}
      <div className="mb-4 grid grid-cols-1 gap-2 sm:grid-cols-2">
        {!isOracleInputVisible && (
          <ActionButton
            action={{ type: 'custom', label: 'Ask the Oracle' }}
            onClick={handleAskOracleClick}
            disabled={disabled}
          />
        )}
        <ActionButton
          action={{ type: 'ANALYZE_SITUATION', label: 'Survey Surroundings' }}
          onClick={onAction}
          disabled={disabled}
        />
      </div>

      {isOracleInputVisible && (
        <div className="mb-4 p-3 border border-purple-500 rounded-lg bg-gray-700/50">
          <input
            type="text"
            value={oracleQuery}
            onChange={(e) => setOracleQuery(e.target.value)}
            placeholder="Ask your question..."
            className="w-full px-3 py-2 bg-gray-900 border border-gray-600 rounded-md text-gray-200 focus:ring-1 focus:ring-purple-500 outline-none mb-2"
            onKeyDown={(e) => e.key === 'Enter' && handleOracleSubmit()}
            autoFocus
            aria-label="Ask the Oracle"
          />
          <div className="flex gap-2">
            <button onClick={handleOracleSubmit} disabled={disabled || !oracleQuery.trim()} className="flex-1 bg-green-600 text-white py-1 rounded hover:bg-green-500">Submit</button>
            <button onClick={() => setIsOracleInputVisible(false)} className="flex-1 bg-gray-500 text-white py-1 rounded hover:bg-gray-400">Cancel</button>
          </div>
        </div>
      )}

      {/* Gemini Generated Actions */}
      <AnimatePresence>
        {geminiGeneratedActions && geminiGeneratedActions.length > 0 && (
          <div className="mb-4">
            <h3 className="text-sm font-semibold text-teal-400 mb-2">Suggested Actions</h3>
            <div className="grid grid-cols-1 gap-2">
              {geminiGeneratedActions.map((action, index) => (
                <ActionButton
                  key={`gemini-${index}`}
                  action={action}
                  onClick={onAction}
                  disabled={disabled || isOracleInputVisible}
                  isGeminiAction
                />
              ))}
            </div>
          </div>
        )}
      </AnimatePresence>

      {/* Standard Context Actions */}
      <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 mb-4">
        {generalActions.map((action, index) => (
          <ActionButton
            key={`gen-${index}`}
            action={action}
            onClick={onAction}
            disabled={disabled || isOracleInputVisible}
          />
        ))}
      </div>

      {/* System/Menu Actions */}
      <div className="mt-6 pt-4 border-t border-gray-700 flex justify-end relative" ref={menuRef}>
        <button
          ref={menuTriggerRef}
          onClick={() => setIsMenuOpen(!isMenuOpen)}
          disabled={disabled}
          className="flex items-center gap-2 px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-lg shadow transition-colors"
          aria-haspopup="menu"
          aria-expanded={isMenuOpen}
        >
          {isMenuOpen ? <X size={20} /> : <Menu size={20} />}
          <span>Menu</span>
          {(unreadDiscoveryCount > 0 || hasNewRateLimitError) && (
            <span className="absolute -top-1 -right-1 h-3 w-3 rounded-full bg-red-500 border-2 border-gray-800 animate-pulse"></span>
          )}
        </button>

        <AnimatePresence>
          {isMenuOpen && (
            <motion.div
              initial={{ opacity: 0, y: 10, scale: 0.95 }}
              animate={{ opacity: 1, y: 0, scale: 1 }}
              exit={{ opacity: 0, y: 10, scale: 0.95 }}
              transition={{ duration: 0.15 }}
              className="absolute bottom-full right-0 mb-2 w-56 bg-gray-800 border border-gray-600 rounded-lg shadow-xl overflow-hidden z-20 flex flex-col p-2 gap-2"
              role="menu"
              // Add keydown listener to the menu container or items.
              // We'll handle it on items, but this container needs to be labeled.
              aria-label="System Menu"
            >
              {systemMenuActions.map(({ action, badgeCount, hasNotification }, idx) => (
                <React.Fragment key={`${action.type}-${idx}`}>
                  {idx === 6 && <div className="h-px bg-gray-600 my-1" aria-hidden="true"></div>}
                  <ActionButton
                    ref={(el) => {
                      if (el) menuItemRefs.current[idx] = el;
                    }}
                    className="w-full text-left"
                    action={action}
                    onClick={(a) => { onAction(a); setIsMenuOpen(false); }}
                    disabled={disabled}
                    badgeCount={badgeCount}
                    hasNotification={hasNotification}
                    role="menuitem"
                    onKeyDown={(e) => handleMenuKeyDown(e, idx)}
                  />
                </React.Fragment>
              ))}
            </motion.div>
          )}
        </AnimatePresence>
      </div>

    </div>
  );
};

export default ActionPane;
