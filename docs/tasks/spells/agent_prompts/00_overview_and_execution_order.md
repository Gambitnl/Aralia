# Spells Task Pack - Overview, Definitions, and Suggested Execution Order

This folder contains agent prompts for completing the spell data migration/normalization work in Aralia.

## Key definitions (use these consistently)

### "V2" spell JSON
"V2" means a spell JSON object that is valid under the current Zod schema:
- `src/systems/spells/validation/spellValidator.ts` (`SpellValidator`)

And is stored at:
- `public/data/spells/level-{N}/{id}.json`

And indexed by:
- `public/data/spells_manifest.json` (generated by `scripts/regenerate-manifest.ts`)

### "Non-legacy"
A spell is considered "legacy" if either is true:
- `legacy: true` in the spell JSON, OR
- `tags` contains `"legacy"`

The app's spell gate checks treat `legacy: true` as a "gap", so the deliverable for "non-legacy" is:
- `legacy` is missing or `false`
- `tags` does not include `"legacy"`

### "Mechanics-usable"
"Mechanics-usable" means the JSON is not just schema-valid, but also encodes enough structure for the game systems to apply it in combat/exploration.

Practical criteria:
- Spell passes `npm run validate` (schema).
- Spell does not rely on a single generic placeholder effect like:
  - one `UTILITY` effect with `utilityType: "other"` and a vague summary
  - unless the spell is inherently utility-only (e.g., informational/communication spells).
- Combat-relevant spells should express their core resolution via structured effects:
  - Attack spells: at least one `DAMAGE` effect with `condition.type: "hit"` and appropriate trigger.
  - Save spells: at least one `DAMAGE` and/or `STATUS_CONDITION` with `condition.type: "save"` and correct `saveType` + `saveEffect`.
  - Hybrid spells (attack + secondary AoE save) should be represented as multiple effects with appropriate triggers (e.g. `after_primary`).

Places to check how mechanics interpret spells:
- `src/systems/spells/effects/*`
- `src/hooks/combat/useTargeting.ts`
- `src/utils/spellAbilityFactory.ts`

### "Glossary-visible"
Spells are shown in the glossary from the manifest-driven spell index:
- `public/data/glossary/index/spells.json` (generated by `scripts/generateGlossaryIndex.js`)

To keep the glossary accurate after any data/schema migration:
- regenerate manifest
- regenerate glossary index

## Source Gathering Standards (Required)
All data gathering for spell references and JSON must adhere to the following:
- **Retrieval**: Use **online official sources** (e.g., D&D Beyond, official errata, or authorized digital toolsets) instead of local or physical book lookups to ensure the most up-to-date phrasing.
- **Extraction**: Extract all prose (descriptions, higher-level details, reaction triggers, etc.) **verbatim**. 
- **No Paraphrasing**: Paraphrasing, summarizing, or interpreting the source text is strictly forbidden. The text must be a direct, character-for-character copy of the official source.

## Creature type constraints (standardization goal)
The codebase already defines canonical DnD creature types here:
- `src/types/creatures.ts` (`CreatureType` enum)

Spells can also use non-core subtype tags (e.g. "Goblinoid") in some places in the codebase. If spell targeting uses `targeting.filter.creatureTypes`, you should standardize how these strings are validated and documented (see Prompt 04).

## Class coverage audit (recommended)
The spell list a class can cast should be encoded on the spell itself via:
- `spell.classes: string[]`

Schema validation ensures class *names* are valid, but it does not ensure class *membership* is correct or complete.

Recommended checks whenever a batch of spells is updated:
- Any spell that is non-legacy should have `classes.length > 0` unless intentionally restricted to a non-class source.
- If the codebase has an authoritative class spell list registry, cross-check `spell.classes` against it and report mismatches.
  - If multiple registries exist (duplicated logic), report them and propose a single SSOT.

## Suggested execution order (to minimize rework)

1) Prompt 02: Non-ASCII guardrails
   - Prevents mojibake/control characters from polluting references/JSON and causing repeated cleanup.

2) Prompt 03: AoE shapes schema + mechanics
   - If you add new AoE representations (wall/emanation/etc), do it before bulk editing spells that require those.

3) Prompt 05: Material components structured model
   - If you change how components are represented, do it before bulk ingesting/verifying reference text for many spells.

4) Prompt 04: Targeting type normalization + attack/save mechanics compatibility
   - Standardize targeting terminology and confirm mechanics interpretation once schema foundations are settled.

5) Prompt 06: Subclass exceptional spell access (glossary + data model)
   - Best done after (4) so base-class spell list membership is well-defined.

6) Prompt 07: Feat-based spell access (glossary + computed index)
   - Can run after (4); may also depend on any data normalization from (2)/(3).

7) Prompt 01: Missing reference files + finalize those spells
   - Can be done earlier for spells that don't depend on AoE/material schema changes, but safest after (2) and (3).

## Always-run commands at the end of each task
- `npx --no-install tsx scripts/regenerate-manifest.ts`
- `node scripts/generateGlossaryIndex.js`
- `npm run validate`
