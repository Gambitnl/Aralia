<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Basic Chat (Sideproject)</title>
    <style>
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        max-width: 720px;
        margin: 24px auto;
        padding: 0 12px;
        font-size: 18px;
        line-height: 1.5;
      }
      #messages {
        padding-left: 18px;
      }
      #composer {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 12px;
      }
      #nameInput {
        width: 160px;
      }
      #messageInput {
        flex: 1;
        min-width: 240px;
      }
      #imageInput {
        max-width: 320px;
      }
      input,
      button {
        font-size: 18px;
      }
      .meta {
        color: rgba(0, 0, 0, 0.55);
        font-size: 14px;
        margin-top: -8px;
        margin-bottom: 12px;
      }
      #nameGate {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.35);
        padding: 16px;
      }
      #nameGate[aria-hidden="false"] {
        display: flex;
      }
      #nameGatePanel {
        background: white;
        border-radius: 10px;
        padding: 16px;
        width: min(520px, 100%);
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.25);
      }
      #nameGatePanel h2 {
        margin: 0 0 10px 0;
        font-size: 18px;
      }
      #nameGatePanel form {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }
      #nameGatePanel input {
        flex: 1;
        min-width: 220px;
      }
      .msg-user {
        font-weight: 600;
        margin-right: 6px;
      }
      .msg-time {
        color: rgba(0, 0, 0, 0.55);
        font-size: 12px;
        margin-left: 6px;
        white-space: nowrap;
      }
      .chat-image {
        display: block;
        max-width: 100%;
        max-height: 420px;
        height: auto;
        border: 1px solid rgba(0, 0, 0, 0.15);
      }
    </style>
  </head>
  <body>
    <h1>Basic Chat</h1>
    <div class="meta">Set your name, then send messages (text or screenshots). Messages persist to a repo file.</div>

    <div id="nameGate" aria-hidden="true">
      <div id="nameGatePanel" role="dialog" aria-modal="true" aria-labelledby="nameGateTitle">
        <h2 id="nameGateTitle">Pick a name for this session</h2>
        <form id="nameGateForm">
          <input id="nameGateInput" type="text" placeholder="Your name" autocomplete="off" required />
          <button type="submit">Continue</button>
        </form>
      </div>
    </div>

    <ul id="messages" aria-live="polite"></ul>

    <form id="composer" autocomplete="off">
      <input id="nameInput" type="text" placeholder="Your name" aria-label="Your name" />
      <input id="messageInput" type="text" placeholder="Type a messageâ€¦" required />
      <input id="imageInput" type="file" accept="image/*" />
      <button type="submit">Send</button>
    </form>

    <script>
      const SESSION_NAME_KEY = "basicChatSessionName.v1";
      const POLL_INTERVAL_MS = 1000;

      const messagesEl = document.getElementById("messages");
      const formEl = document.getElementById("composer");
      const nameEl = document.getElementById("nameInput");
      const inputEl = document.getElementById("messageInput");
      const imageEl = document.getElementById("imageInput");
      const nameGateEl = document.getElementById("nameGate");
      const nameGateFormEl = document.getElementById("nameGateForm");
      const nameGateInputEl = document.getElementById("nameGateInput");

      /**
       * @typedef {{
       *  id: number,
       *  ts: number,
       *  user: string,
       *  kind: 'text'|'image',
       *  text?: string,
       *  imageUrl?: string
       * }} ChatMessage
       */

      /** @type {ChatMessage[]} */
      let messages = [];
      let lastSeenId = 0;
      let pollTimer = null;
      let pollInFlight = false;

      function getUserName() {
        const name = (nameEl.value || "").trim();
        return name || "Anonymous";
      }

      function setNameGateOpen(isOpen) {
        nameGateEl.setAttribute("aria-hidden", isOpen ? "false" : "true");
        inputEl.disabled = isOpen;
        imageEl.disabled = isOpen;
        formEl.querySelector("button[type='submit']").disabled = isOpen;
        if (isOpen) nameGateInputEl.focus();
        else inputEl.focus();
      }

      function setSessionName(name) {
        const trimmed = (name || "").trim();
        sessionStorage.setItem(SESSION_NAME_KEY, trimmed);
        nameEl.value = trimmed;
      }

      function formatTime(ts) {
        try {
          return new Date(ts).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });
        } catch {
          return "";
        }
      }

      /** @param {any} m */
      function normalizeMessage(m) {
        if (!m || typeof m !== "object") return null;
        const id = typeof m.id === "number" ? m.id : Number(m.id) || 0;
        if (!Number.isFinite(id) || id <= 0) return null;
        return {
          id,
          ts: typeof m.ts === "number" ? m.ts : Date.now(),
          user: typeof m.user === "string" ? m.user : "Anonymous",
          kind: m.kind === "image" ? "image" : "text",
          text: typeof m.text === "string" ? m.text : "",
          imageUrl: typeof m.imageUrl === "string" ? m.imageUrl : undefined,
        };
      }

      async function fetchMessages(sinceId) {
        const url = new URL("/api/messages", window.location.href);
        if (sinceId && Number.isFinite(sinceId) && sinceId > 0) {
          url.searchParams.set("since", String(sinceId));
        }
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) throw new Error(`GET /api/messages failed: ${res.status}`);
        const data = await res.json();
        const list = data && typeof data === "object" ? data.messages : null;
        if (!Array.isArray(list)) return [];
        return list.map(normalizeMessage).filter(Boolean);
      }

      /** @param {ChatMessage[]} incoming */
      function applyIncoming(incoming) {
        if (!incoming.length) return;
        for (const msg of incoming) {
          if (msg.id <= lastSeenId) continue;
          messages.push(msg);
          lastSeenId = Math.max(lastSeenId, msg.id);
          messagesEl.appendChild(renderMessage(msg));
        }
      }

      /** @param {ChatMessage} msg */
      function renderMessage(msg) {
        const li = document.createElement("li");

        const header = document.createElement("span");
        const user = document.createElement("span");
        user.className = "msg-user";
        user.textContent = `${msg.user}:`;
        header.appendChild(user);

        const time = document.createElement("span");
        time.className = "msg-time";
        time.textContent = formatTime(msg.ts);
        header.appendChild(time);

        li.appendChild(header);

        if (msg.kind === "text") {
          const body = document.createElement("span");
          body.textContent = ` ${msg.text || ""}`;
          li.appendChild(body);
          return li;
        }

        if (msg.text) {
          const cap = document.createElement("div");
          cap.textContent = msg.text;
          li.appendChild(cap);
        }

        const img = document.createElement("img");
        img.className = "chat-image";
        img.alt = msg.text ? `Image: ${msg.text}` : "Image";
        if (msg.imageUrl) img.src = msg.imageUrl;
        li.appendChild(img);

        return li;
      }

      function rerenderAll() {
        messagesEl.replaceChildren(...messages.map(renderMessage));
      }

      async function refreshAll() {
        const all = await fetchMessages(0);
        messages = all;
        lastSeenId = all.reduce((acc, m) => Math.max(acc, m.id || 0), 0);
        rerenderAll();
      }

      function startPolling() {
        if (pollTimer) return;
        pollTimer = setInterval(async () => {
          if (pollInFlight) return;
          pollInFlight = true;
          try {
            const incoming = await fetchMessages(lastSeenId);
            applyIncoming(incoming);
          } catch {
            // ignore transient errors
          } finally {
            pollInFlight = false;
          }
        }, POLL_INTERVAL_MS);
      }

      async function postTextMessage(text) {
        const msg = text.trim();
        if (!msg) return;
        const res = await fetch(new URL("/api/messages", window.location.href), {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ user: getUserName(), text: msg }),
        });
        if (!res.ok) throw new Error(`POST /api/messages failed: ${res.status}`);
        const data = await res.json();
        const normalized = normalizeMessage(data && typeof data === "object" ? data.message : null);
        if (normalized) applyIncoming([normalized]);
      }

      /** @param {File} file */
      function fileToDataUrl(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(String(reader.result || ""));
          reader.onerror = () => reject(reader.error || new Error("Failed to read image"));
          reader.readAsDataURL(file);
        });
      }

      async function postImageMessage(file, captionText) {
        const caption = captionText.trim();
        const imageDataUrl = await fileToDataUrl(file);
        const res = await fetch(new URL("/api/messages", window.location.href), {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ user: getUserName(), text: caption, imageDataUrl }),
        });
        if (!res.ok) throw new Error(`POST /api/messages failed: ${res.status}`);
        const data = await res.json();
        const normalized = normalizeMessage(data && typeof data === "object" ? data.message : null);
        if (normalized) applyIncoming([normalized]);
      }

      function tryExtractImageFromPasteEvent(e) {
        const items = e.clipboardData?.items;
        if (!items) return null;
        for (const item of items) {
          if (item.kind !== "file") continue;
          if (!item.type.startsWith("image/")) continue;
          return item.getAsFile();
        }
        return null;
      }

      formEl.addEventListener("submit", (e) => {
        e.preventDefault();
        if (!nameEl.value.trim()) {
          setNameGateOpen(true);
          return;
        }
        const file = imageEl.files?.[0] ?? null;
        const text = inputEl.value;

        const button = formEl.querySelector("button[type='submit']");
        if (button) button.disabled = true;

        Promise.resolve()
          .then(async () => {
            if (file) {
              await postImageMessage(file, text);
            } else {
              await postTextMessage(text);
            }
          })
          .catch((err) => {
            alert(String(err?.message || err || "Failed to send message."));
          })
          .finally(() => {
            inputEl.value = "";
            imageEl.value = "";
            if (button) button.disabled = false;
            inputEl.focus();
          });
      });

      nameEl.value = sessionStorage.getItem(SESSION_NAME_KEY) || "";
      nameEl.addEventListener("change", () => {
        setSessionName(nameEl.value);
        if (!nameEl.value.trim()) setNameGateOpen(true);
        else startPolling();
      });

      nameGateFormEl.addEventListener("submit", (e) => {
        e.preventDefault();
        setSessionName(nameGateInputEl.value);
        if (nameEl.value.trim()) {
          setNameGateOpen(false);
          startPolling();
        }
      });

      // Paste screenshots/images directly into the textbox.
      inputEl.addEventListener("paste", (e) => {
        const file = tryExtractImageFromPasteEvent(e);
        if (!file) return;
        e.preventDefault();

        const dt = new DataTransfer();
        dt.items.add(file);
        imageEl.files = dt.files;
      });

      (async () => {
        try {
          await refreshAll();
        } catch (err) {
          console.error(err);
        }

        if (!nameEl.value.trim()) {
          setNameGateOpen(true);
        } else {
          inputEl.focus();
          startPolling();
        }
      })();
    </script>
  </body>
</html>
